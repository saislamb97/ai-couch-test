<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WS Chat â€” 3D Viseme Debug (ARKIT-15)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
  <style>
    html, body { height: 100%; }
    canvas { image-rendering: auto; }
    .json-pre { tab-size: 2; }
    label span.value { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body class="bg-slate-50 min-h-screen">
  <div class="mx-auto max-w-7xl p-4 space-y-4">
    <!-- Header -->
    <header class="flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-semibold text-slate-900">WS Chat â€” 3D Viseme Debug (ARKIT-15)</h1>
        <p class="text-slate-500 text-sm">
          Streams from <span class="font-mono">/ws/chat/</span> and drives an RPM avatar with <strong>ARKIT-15</strong> visemes + server timings.
        </p>
      </div>
      <div class="flex items-center gap-3">
        <div id="emotionBadge" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-slate-400 inline-block"></span> emotion: â€”
        </div>
        <div id="audioBadge" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-emerald-500 inline-block"></span> audio: unmuted
        </div>
        <div id="wsStatus" class="inline-flex items-center gap-2 rounded-full bg-slate-200 px-2 py-1 text-xs text-slate-700">
          <span class="h-2 w-2 rounded-full bg-slate-500 inline-block"></span> disconnected
        </div>
      </div>
    </header>

    <!-- Connect -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="grid gap-3 md:grid-cols-12">
        <div class="md:col-span-3">
          <label class="text-xs font-medium text-slate-600">Agent bot_id (UUID)</label>
          <input id="botId" class="w-full rounded border border-slate-300 p-2" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
        </div>
        <div class="md:col-span-3">
          <label class="text-xs font-medium text-slate-600">Visitor thread_id</label>
          <input id="threadId" class="w-full rounded border border-slate-300 p-2" placeholder="user_0123456789abcdef">
        </div>
        <div class="md:col-span-2">
          <label class="text-xs font-medium text-slate-600">Website language</label>
          <select id="websiteLanguage" class="w-full rounded border border-slate-300 p-2">
            <option value="en" selected>en</option>
            <option value="es">es</option>
            <option value="fr">fr</option>
          </select>
        </div>
        <div class="md:col-span-2">
          <label class="text-xs font-medium text-slate-600">API Key</label>
          <input id="apiKey" class="w-full rounded border border-slate-300 p-2" placeholder="Api-Key value">
        </div>
        <div class="md:col-span-2 flex items-end">
          <button id="connectBtn" class="w-full rounded bg-blue-600 px-3 py-2 text-white hover:bg-blue-700">Connect</button>
        </div>
        <div class="md:col-span-12 flex flex-wrap items-end gap-2 pt-1">
          <button id="disconnectBtn" class="rounded bg-slate-200 px-3 py-2 text-slate-800 hover:bg-slate-300" disabled>Disconnect</button>
          <div class="ml-2 inline-flex gap-2">
            <button id="btnToggleMute" class="rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900" disabled>Mute</button>
            <button id="btnStopAudio" class="rounded bg-rose-600 px-3 py-2 text-white hover:bg-rose-700" disabled>Stop Audio</button>
          </div>
          <button id="btnPing" class="ml-auto rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900" disabled>Ping</button>
        </div>
      </div>
    </section>

    <!-- Avatar (Ready Player Me) -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4 space-y-3">
      <div class="grid gap-3 md:grid-cols-12">
        <div class="md:col-span-7">
          <label class="text-xs font-medium text-slate-600">Ready Player Me GLB URL</label>
          <input id="glbUrl" class="w-full rounded border border-slate-300 p-2 font-mono text-xs" placeholder="https://models.readyplayer.me/.../model.glb">
        </div>
        <div class="md:col-span-2 flex items-end">
          <button id="loadAvatarBtn" class="w-full rounded bg-emerald-600 px-3 py-2 text-white hover:bg-emerald-700">Load Avatar</button>
        </div>
        <div class="md:col-span-3 grid grid-cols-3 gap-2 items-end">
          <div class="col-span-3">
            <label class="text-xs font-medium text-slate-600 flex items-center justify-between">
              <span>Viseme gain</span>
              <span class="value" id="visemeGainVal">1.00Ã—</span>
            </label>
            <input id="visemeGain" type="range" min="50" max="200" step="5" value="100" class="w-full">
          </div>
          <div class="col-span-3">
            <label class="text-xs font-medium text-slate-600 flex items-center justify-between">
              <span>Smoothing (lerp)</span>
              <span class="value" id="visemeSmoothVal">0.05</span>
            </label>
            <input id="visemeSmooth" type="range" min="0" max="80" step="5" value="5" class="w-full">
          </div>
          <!-- NEW: Jaw gain control -->
          <div class="col-span-3">
            <label class="text-xs font-medium text-slate-600 flex items-center justify-between">
              <span>Jaw gain</span>
              <span class="value" id="jawGainVal">1.20Ã—</span>
            </label>
            <input id="jawGain" type="range" min="50" max="220" step="5" value="120" class="w-full">
          </div>
          <div class="col-span-3">
            <button id="btnVisemeTest" class="w-full rounded bg-slate-800 px-3 py-2 text-white hover:bg-slate-900">Test Mouth</button>
          </div>
        </div>
      </div>
      <div id="threeRoot" class="w-full h-[460px] rounded border border-slate-200 bg-slate-100 overflow-hidden"></div>
      <div class="text-xs text-slate-600">
        This viewer expects <strong>ARKIT-15</strong> arrays from the backend. Detected ARKit morphs are logged below.
      </div>
    </section>

    <!-- Send -->
    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="flex gap-2">
        <input id="chatInput" class="flex-1 rounded border border-slate-300 p-3 font-mono text-sm" placeholder='Type text and press Enter or click "Send"' />
        <button id="sendBtn" class="rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700" disabled>Send</button>
      </div>

      <div class="mt-3 grid gap-3 md:grid-cols-12 items-center">
        <div class="md:col-span-8 flex items-center gap-3">
          <button id="pttButton"
                  class="rounded bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Hold to record, release to send"
                  disabled>ðŸŽ¤ Hold to Talk</button>
          <button id="micPermBtn"
                  class="hidden rounded bg-amber-600 px-3 py-2 text-white hover:bg-amber-700"
                  title="Grant microphone permission">ðŸ”’ Grant mic</button>
          <div id="micStatus" class="text-xs text-slate-600">mic: idle</div>
        </div>

        <div class="md:col-span-4 grid grid-cols-2 items-center gap-3">
          <label class="inline-flex items-center gap-2 text-xs text-slate-700 col-span-2 sm:col-span-1">
            <input id="muteOnSend" type="checkbox" class="rounded border-slate-300 text-blue-600">
            <span>Start this run muted</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Streams -->
    <section class="grid gap-4 lg:grid-cols-3">
      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Text tokens (raw)</h2>
          <div class="flex gap-2">
            <button id="textCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="textClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="textTokens" class="h-48 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
      </div>

      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Slides (pretty JSON)</h2>
          <div class="flex gap-2">
            <button id="slidesCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="slidesClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="slidesLog" class="json-pre h-80 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre"></pre>
      </div>

      <div class="rounded-2xl bg-white ring-1 ring-black/5 p-4 flex flex-col">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold text-slate-700">Audio + visemes</h2>
          <div class="flex gap-2">
            <button id="audioCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
            <button id="audioClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
          </div>
        </div>
        <pre id="audioLog" class="h-80 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
        <audio id="audioPlayer" class="mt-2 w-full" controls></audio>
      </div>
    </section>

    <section class="rounded-2xl bg-white ring-1 ring-black/5 p-4">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-sm font-semibold text-slate-700">Events</h2>
        <div class="flex gap-2">
          <button id="evtCopy" class="rounded bg-slate-200 px-2 py-1 text-xs">Copy</button>
          <button id="evtClear" class="rounded bg-slate-200 px-2 py-1 text-xs">Clear</button>
        </div>
      </div>
      <pre id="evtLog" class="h-60 overflow-y-auto bg-slate-50 border border-slate-200 rounded p-2 text-xs font-mono whitespace-pre-wrap"></pre>
    </section>
  </div>

  <!-- Import map for Three ESM -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>
<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // ---------- config / helpers ----------
  const DEBUG = true;

  const $ = (s) => document.querySelector(s);
  const now = () => new Date().toLocaleTimeString();
  const logLine = (el, line) => { el.textContent += (el.textContent ? "\n" : "") + line; el.scrollTop = el.scrollHeight; };
  const copyText = (el) => navigator.clipboard.writeText(el.textContent || "");
  const clearEl = (el) => el.textContent = "";

  function normalizeThreadId(raw) {
    const x = (raw || '').trim();
    const m = x.match(/([0-9a-f]{16})$/i);
    if (x.startsWith('user_') && m) return `user_${m[1].toLowerCase()}`;
    if (m) return `user_${m[1].toLowerCase()}`;
    return x;
  }

  async function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve((reader.result || '').toString());
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  function b64ToBlob(b64) {
    // backend sends MP3; use audio/mpeg
    let raw = b64, outMime = 'audio/mpeg';
    if (typeof b64 === 'string' && b64.startsWith('data:')) {
      raw = b64.split(',')[1] || '';
    }
    const bin = atob(raw);
    const buf = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) buf[i] = bin.charCodeAt(i);
    return new Blob([buf], { type: outMime });
  }
  const safeRevoke = (url) => { try { if (url) URL.revokeObjectURL(url); } catch {} };

  // Emotion badge
  function setEmotionBadge(name, intensity) {
    const el = $('#emotionBadge');
    const label = name ? `${name}` : 'â€”';
    const dots = { joy:'bg-amber-400', anger:'bg-rose-500', sadness:'bg-blue-500', fear:'bg-purple-500', surprise:'bg-emerald-500' };
    const dot = dots[(name||'').toLowerCase()] || 'bg-slate-400';
    const strong = Math.max(1, Math.min(3, Number(intensity ?? 1)));
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${dot} inline-block"></span> emotion: ${label} (${strong})`;
    el.classList.remove('bg-amber-100','bg-rose-100','bg-blue-100','bg-emerald-100');
    if ((name||'').toLowerCase()==='joy') el.classList.add('bg-amber-100');
    if ((name||'').toLowerCase()==='anger') el.classList.add('bg-rose-100');
    if ((name||'').toLowerCase()==='sadness') el.classList.add('bg-blue-100');
    if ((name||'').toLowerCase()==='surprise') el.classList.add('bg-emerald-100');
  }

  // ---------- WS ----------
  let ws = null;
  let audioMuted = false;

  // emotion-first gating (buffer tokens until we see emotion or timeout)
  let expectingEmotion = false;
  let tokenBuffer = '';
  let emotionFlushTimer = null;
  const EMOTION_GUARD_MS = 600;

  function beginEmotionGuard() {
    expectingEmotion = true;
    tokenBuffer = '';
    try { clearTimeout(emotionFlushTimer); } catch {}
    emotionFlushTimer = setTimeout(() => flushTokenBuffer(), EMOTION_GUARD_MS);
    setEmotionBadge('â€¦', 1);
  }
  function onEmotionArrived() {
    expectingEmotion = false;
    try { clearTimeout(emotionFlushTimer); } catch {}
    emotionFlushTimer = null;
    flushTokenBuffer();
  }
  function flushTokenBuffer() {
    if (!tokenBuffer) return;
    $('#textTokens').textContent += tokenBuffer;
    $('#textTokens').scrollTop = $('#textTokens').scrollHeight;
    tokenBuffer = '';
  }

  function setBadge(connected){
    const el = $('#wsStatus');
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${connected ? 'bg-emerald-500' : 'bg-slate-500'} inline-block"></span> ${connected ? 'connected' : 'disconnected'}`;
    el.classList.toggle('bg-emerald-100', connected);
    el.classList.toggle('bg-slate-200', !connected);
  }
  function setAudioBadge(muted){
    audioMuted = !!muted;
    const el = $('#audioBadge');
    const dot = audioMuted ? 'bg-rose-500' : 'bg-emerald-500';
    const txt = audioMuted ? 'audio: muted' : 'audio: unmuted';
    el.innerHTML = `<span class="h-2 w-2 rounded-full ${dot} inline-block"></span> ${txt}`;
    el.classList.toggle('bg-rose-100', audioMuted);
    el.classList.toggle('bg-emerald-100', !audioMuted);
    $('#btnToggleMute').textContent = audioMuted ? 'Unmute' : 'Mute';
  }
  function buildWsUrl() {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const bot = encodeURIComponent($('#botId').value.trim());
    const thr = encodeURIComponent(normalizeThreadId($('#threadId').value.trim()));
    const lang = encodeURIComponent($('#websiteLanguage').value.trim() || 'en');
    const key = encodeURIComponent($('#apiKey').value.trim());
    return `${proto}://${location.host}/ws/chat/?bot_id=${bot}&thread_id=${thr}&website_language=${lang}&api_key=${key}`;
  }
  function setAuthCookie(){
    const key = $('#apiKey').value.trim();
    if (!key) return;
    const secure = location.protocol === 'https:' ? '; Secure' : '';
    document.cookie = `api_key=${encodeURIComponent(key)}; path=/; SameSite=Lax${secure}`;
  }

  // ---------- Three.js scene ----------
  let scene, camera, renderer, controls, avatarRoot = null;
  let arkitTargets = [];  // { mesh, dict, dictLc, influences, a: {jawOpen,â€¦} }
  const threeRoot = $('#threeRoot');

  function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);

    const w = threeRoot.clientWidth, h = threeRoot.clientHeight;
    camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
    camera.position.set(0, 1.55, 2.2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(w, h);
    threeRoot.innerHTML = '';
    threeRoot.appendChild(renderer.domElement);

    // lights
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(1, 1.8, 2.5);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.6);
    fill.position.set(-2, 1.2, 0.6);
    scene.add(fill);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.5, 0);
    controls.enableDamping = true;

    window.addEventListener('resize', onResize);
    tick();
  }
  function onResize() {
    if (!renderer || !camera) return;
    const w = threeRoot.clientWidth, h = threeRoot.clientHeight;
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  function tick(){
    requestAnimationFrame(tick);
    controls?.update();
    renderer?.render(scene, camera);
  }

  function clearAvatar() {
    if (avatarRoot) {
      scene.remove(avatarRoot);
      avatarRoot.traverse(n => {
        if (n.isMesh) {
          n.geometry?.dispose?.();
          if (Array.isArray(n.material)) n.material.forEach(m=>m.dispose?.());
          else n.material?.dispose?.();
        }
      });
      avatarRoot = null;
    }
    arkitTargets = [];
  }

  function loadAvatar(glbUrl) {
    clearAvatar();
    const loader = new GLTFLoader().setCrossOrigin('anonymous');
    loader.load(glbUrl, (gltf) => {
      avatarRoot = gltf.scene || gltf.scenes?.[0];
      scene.add(avatarRoot);
      avatarRoot.scale.set(1,1,1);

      controls.target.set(0, 1.55, 0);
      camera.position.set(0, 1.55, 2.1);

      scanBlendshapes(avatarRoot);
      reportBlendshapes();

      if (!arkitTargets.length) {
        logLine($('#evtLog'), `[${now()}] âš ï¸ No ARKit morph targets were found on this model.`);
      } else {
        logLine($('#evtLog'), `[${now()}] avatar loaded; ARKit morph sets found=${arkitTargets.length}`);
      }
    }, undefined, (err) => {
      logLine($('#evtLog'), `[${now()}] avatar load error: ${err?.message || err}`);
    });
  }

  const ARKIT_CANON = [
    'jawOpen','mouthClose','mouthFunnel','mouthPucker',
    'mouthSmileLeft','mouthSmileRight',
    'mouthLeft','mouthRight',                    // NEW
    'mouthFrownLeft','mouthFrownRight',
    'mouthDimpleLeft','mouthDimpleRight','mouthStretchLeft','mouthStretchRight',
    'tongueOut'
  ];
  const ARKIT_SYNONYMS = {
    jawOpen:        ['jawOpen','mouthOpen'],
    mouthClose:     ['mouthClose'],
    mouthFunnel:    ['mouthFunnel','lipsFunnel'],
    mouthPucker:    ['mouthPucker','lipsPucker'],
    mouthSmileLeft: ['mouthSmileLeft','mouthSmile'],
    mouthSmileRight:['mouthSmileRight'],
    mouthLeft:      ['mouthLeft'],               // NEW
    mouthRight:     ['mouthRight'],              // NEW
    mouthFrownLeft: ['mouthFrownLeft'],
    mouthFrownRight:['mouthFrownRight'],
    mouthDimpleLeft:['mouthDimpleLeft'],
    mouthDimpleRight:['mouthDimpleRight'],
    mouthStretchLeft:['mouthStretchLeft'],
    mouthStretchRight:['mouthStretchRight'],
    tongueOut:      ['tongueOut']
  };

  function scanBlendshapes(root) {
    arkitTargets = [];
    root.traverse(obj => {
      if (!obj.isMesh || !obj.morphTargetDictionary || !obj.morphTargetInfluences) return;
      const dict = obj.morphTargetDictionary;
      const dictLc = {};
      for (const [k,v] of Object.entries(dict)) dictLc[String(k).toLowerCase()] = v;

      const a = {};
      let hasARK = false;
      for (const key of ARKIT_CANON) {
        for (const name of ARKIT_SYNONYMS[key]) {
          const idx = dictLc[name.toLowerCase()];
          if (idx != null) { a[key] = idx; hasARK = true; break; }
        }
      }
      if (hasARK) {
        arkitTargets.push({ mesh: obj, dict, dictLc, influences: obj.morphTargetInfluences, a });
      }
    });
  }

  function reportBlendshapes() {
    const aFound = new Set();
    for (const t of arkitTargets) {
      for (const [k, arr] of Object.entries(ARKIT_SYNONYMS)) {
        for (const n of arr) if (t.dictLc[n.toLowerCase()] != null) aFound.add(n);
      }
    }
    logLine($('#evtLog'), `[${now()}] ARKit morphs: ${aFound.size ? Array.from(aFound).sort().join(', ') : 'none'}`);
  }

  // UI gain + smoothing + jaw gain
  const gainEl = $('#visemeGain');
  const gainVal = $('#visemeGainVal');
  const smoothEl = $('#visemeSmooth');
  const smoothVal = $('#visemeSmoothVal');
  const jawEl = $('#jawGain');
  const jawVal = $('#jawGainVal');

  function getGain() { return (Number(gainEl.value || 100) / 100); }
  function getSmooth() { return (Number(smoothEl.value || 0) / 100); }
  function getJawGain() { return (Number(jawEl?.value || 100) / 100); }

  gainEl.oninput = () => gainVal.textContent = `${getGain().toFixed(2)}Ã—`;
  smoothEl.oninput = () => smoothVal.textContent = `${getSmooth().toFixed(2)}`;
  jawEl.oninput = () => jawVal.textContent = `${getJawGain().toFixed(2)}Ã—`;

  function resetMorphs() {
    const zero = new Array(15).fill(0);
    prevFrame = zero.slice();
    for (const t of arkitTargets) {
      const d = t.a, inf = t.influences;
      const fields = [
        'jawOpen','mouthFunnel','mouthClose','mouthPucker',
        'mouthSmileLeft','mouthSmileRight',
        'mouthLeft','mouthRight',                     // NEW
        'mouthFrownLeft','mouthFrownRight',
        'mouthDimpleLeft','mouthDimpleRight','mouthStretchLeft','mouthStretchRight',
        'tongueOut'
      ];
      for (const key of fields) { const k = d[key]; if (k != null) inf[k] = 0; }
    }
  }

  let prevFrame = new Array(15).fill(0);
  function applyVisemeFrame(frame /* ARKIT-15 */) {
    const f = Array.isArray(frame) ? frame.slice(0,15) : [];
    const out = new Array(15).fill(0);
    const g = getGain();
    const s = getSmooth();
    for (let i=0;i<15;i++){
      const target = Math.max(0, Math.min(1, Number(f[i] ?? 0)));
      const sm = prevFrame[i] + (target - prevFrame[i]) * (1 - s); // low-pass only (timing from backend)
      out[i] = Math.max(0, Math.min(1, sm * g));
    }
    // Jaw-only boost after global gain
    out[0] = Math.max(0, Math.min(1, out[0] * getJawGain()));
    prevFrame = out;

    for (const t of arkitTargets) {
      const d = t.a, inf = t.influences;
      if (d.jawOpen      != null) inf[d.jawOpen]      = out[0];
      if (d.mouthFunnel  != null) inf[d.mouthFunnel]  = out[1];
      if (d.mouthClose   != null) inf[d.mouthClose]   = out[2];
      if (d.mouthPucker  != null) inf[d.mouthPucker]  = out[3];
      const more = [
        ["mouthSmileLeft",4],["mouthSmileRight",5],
        ["mouthLeft",6],["mouthRight",7],                        // NEW
        ["mouthFrownLeft",8],["mouthFrownRight",9],
        ["mouthDimpleLeft",10],["mouthDimpleRight",11],["mouthStretchLeft",12],["mouthStretchRight",13],
        ["tongueOut",14],
      ];
      for (const [canon, idx] of more) {
        const k = d[canon];
        if (k != null) inf[k] = out[idx];
      }
    }
  }

  // ---------- audio queue + viseme sync ----------
  const audioEl = $('#audioPlayer');
  const audioQ = [];
  let playing = false;
  let activeFrames = [];  // [[15]]
  let activeTimes = null; // [seconds]
  let activeUrl = null;
  let visemeRAF = null;

  function lerpFrame(a, b, t) {
    const out = new Array(15).fill(0);
    const tt = Math.max(0, Math.min(1, t));
    for (let i=0;i<15;i++) {
      const av = Number(a?.[i] ?? 0);
      const bv = Number(b?.[i] ?? 0);
      out[i] = av + (bv - av) * tt;
    }
    return out;
  }

  function startVisemeLoop(){
    stopVisemeLoop();
    let lastIdx = 0;
    const step = () => {
      if (!activeFrames.length || !Array.isArray(activeTimes) || activeTimes.length !== activeFrames.length) {
        visemeRAF = requestAnimationFrame(step);
        return;
      }
      const t = audioEl.currentTime;

      if (t <= activeTimes[0]) {
        applyVisemeFrame(activeFrames[0]);
      } else if (t >= activeTimes[activeTimes.length - 1]) {
        applyVisemeFrame(activeFrames[activeFrames.length - 1]);
      } else {
        while (lastIdx < activeTimes.length - 2 && t >= activeTimes[lastIdx + 1]) lastIdx++;
        const t0 = activeTimes[lastIdx];
        const t1 = activeTimes[lastIdx + 1];
        const f0 = activeFrames[lastIdx];
        const f1 = activeFrames[lastIdx + 1];
        const alpha = (t1 > t0) ? (t - t0) / (t1 - t0) : 0;
        applyVisemeFrame(lerpFrame(f0, f1, alpha));
      }

      visemeRAF = requestAnimationFrame(step);
    };
    visemeRAF = requestAnimationFrame(step);
  }
  function stopVisemeLoop(){
    if (visemeRAF) cancelAnimationFrame(visemeRAF);
    visemeRAF = null;
  }

  function clearAudioQueue() {
    try { audioEl.pause(); } catch {}
    if (activeUrl) safeRevoke(activeUrl);
    audioEl.removeAttribute('src');
    audioEl.load();
    while (audioQ.length) {
      const item = audioQ.shift();
      if (item?.url) safeRevoke(item.url);
    }
    playing = false;
    activeFrames = [];
    activeTimes = null;
    activeUrl = null;
    stopVisemeLoop();
    resetMorphs();
  }

  function queueAudio(b64, frames, times, info='') {
    try {
      const blob = b64ToBlob(b64);
      const url = URL.createObjectURL(blob);

      if (!Array.isArray(frames) || !Array.isArray(times) || frames.length !== times.length) {
        logLine($('#audioLog'), `[${now()}] ! malformed viseme payload (frames/times length mismatch)`);
        URL.revokeObjectURL(url);
        return;
      }

      audioQ.push({ url, frames, times });
      logLine($('#audioLog'), `[${now()}] queued (audio/mpeg) frames=${frames.length} ${info}`);
      playNext();
    } catch (e) {
      logLine($('#audioLog'), `[${now()}] ! queue error: ${e}`);
    }
  }

  function playNext(){
    if (playing || !audioQ.length) return;
    playing = true;

    if (activeUrl) safeRevoke(activeUrl);

    const item = audioQ.shift();
    activeFrames = item.frames || [];
    activeTimes = Array.isArray(item.times) ? item.times : null;
    activeUrl = item.url;

    audioEl.src = item.url;

    audioEl.onloadedmetadata = () => {
      if (DEBUG) logLine($('#audioLog'), `[${now()}] â–¶ playing dur=${isFinite(audioEl.duration)?audioEl.duration.toFixed(2):'?' }s`);
    };
    const onFinish = () => {
      safeRevoke(activeUrl);
      playing = false;
      activeFrames = [];
      activeTimes = null;
      stopVisemeLoop();
      resetMorphs();
      playNext();
    };
    audioEl.onended = onFinish;
    audioEl.onerror = onFinish;
    audioEl.onplay = () => startVisemeLoop();
    audioEl.onpause = () => stopVisemeLoop();

    audioEl.muted = audioMuted; // ensure local player mirrors badge state
    audioEl.play().catch(err => {
      logLine($('#audioLog'), `[${now()}] ! playback error: ${err}`);
      onFinish();
    });
  }

  // ---------- WS wiring ----------
  $('#loadAvatarBtn').onclick = (e) => {
    e.preventDefault();
    const url = $('#glbUrl').value.trim();
    if (!url) { alert('Provide a Ready Player Me GLB URL'); return; }
    loadAvatar(url);
  };

  // Test mouth button (jawOpen = 1 for 600ms)
  $('#btnVisemeTest').onclick = (e) => {
    e.preventDefault();
    const f = new Array(15).fill(0); f[0] = 1;
    applyVisemeFrame(f);
    setTimeout(() => applyVisemeFrame(new Array(15).fill(0)), 600);
  };

  $('#connectBtn').onclick = (e) => {
    e.preventDefault();
    const bot=$('#botId').value.trim(), thr=$('#threadId').value.trim(), key=$('#apiKey').value.trim();
    if (!bot || !thr || !key) { alert('bot_id, thread_id, api key required'); return; }
    $('#threadId').value = normalizeThreadId(thr);
    setAuthCookie();
    const url = buildWsUrl();
    ws = new WebSocket(url);
    ws.onopen = () => {
      setBadge(true);
      $('#sendBtn').disabled = false;
      $('#disconnectBtn').disabled = false;
      $('#btnPing').disabled = false;
      $('#btnToggleMute').disabled = false;
      $('#btnStopAudio').disabled = false;
      $('#pttButton').disabled = false;
      updateMicPermBadge();
      logLine($('#evtLog'), `[${now()}] open ${url}`);
    };
    ws.onclose = (ev) => {
      setBadge(false);
      $('#sendBtn').disabled = true;
      $('#disconnectBtn').disabled = true;
      $('#btnPing').disabled = true;
      $('#btnToggleMute').disabled = true;
      $('#btnStopAudio').disabled = true;
      $('#pttButton').disabled = true;
      logLine($('#evtLog'), `[${now()}] close code=${ev.code}`);
      clearAudioQueue();
      expectingEmotion = false; tokenBuffer = ''; try { clearTimeout(emotionFlushTimer); } catch {}
    };
    ws.onerror = (ev) => logLine($('#evtLog'), `[${now()}] error ${ev?.message || ''}`);

    ws.onmessage = (evt) => {
      let msg = {};
      try { msg = JSON.parse(evt.data || '{}'); } catch { msg = {}; }
      const t = msg.type || '';
      switch (t) {
        case 'connected':
          logLine($('#evtLog'), `[${now()}] connected bot=${msg.bot_id} thread=${msg.thread_id}`);
          break;

        case 'response_start':
          logLine($('#evtLog'), `[${now()}] response_start`);
          beginEmotionGuard();
          break;

        case 'audio_muted':
          setAudioBadge(!!msg.muted);
          audioEl.muted = !!msg.muted;
          logLine($('#evtLog'), `[${now()}] audio_muted=${!!msg.muted}`);
          break;

        case 'stop_audio':
          clearAudioQueue();
          logLine($('#evtLog'), `[${now()}] stop_audio`);
          break;

        case 'text_token': {
          const tok = (msg.token || '').toString();
          if (expectingEmotion) { tokenBuffer += tok; }
          else {
            $('#textTokens').textContent += tok;
            $('#textTokens').scrollTop = $('#textTokens').scrollHeight;
          }
          break;
        }

        case 'emotion': {
          const e = msg.emotion || {};
          setEmotionBadge(e.name, e.intensity);
          onEmotionArrived();
          if (DEBUG) console.log('[emotion]', e);
          break;
        }

        case 'slides_response': {
          const payload = ('slides' in msg) ? {slides: msg.slides}
                        : ('slides_raw' in msg) ? {slides_raw: msg.slides_raw} : msg;
          const pretty = JSON.stringify(payload, null, 2);
          logLine($('#slidesLog'), pretty + "\n");
          break;
        }

        case 'slides_done':
          logLine($('#slidesLog'), `-- slides_done --`);
          break;

        case 'audio_response': {
          // backend contract (authoritative):
          // audio: base64 mp3
          // viseme: [[15]*N] ARKIT-15
          // viseme_times: [seconds] length==N
          // viseme_format: "arkit15" (ignored here; we only support ARKIT-15)
          const b64 = msg.audio || '';
          const frames = Array.isArray(msg.viseme) ? msg.viseme : [];
          const times = Array.isArray(msg.viseme_times) ? msg.viseme_times.map(Number) : null;

          if (!frames.length || !times || times.length !== frames.length) {
            logLine($('#audioLog'), `[${now()}] ! rejected audio_response (missing/invalid ARKIT-15 frames or times)`);
            break;
          }

          // optional debug preview
          const preview = typeof b64 === 'string'
            ? (b64.startsWith('data:') ? b64.split(',')[1] || '' : b64)
            : '';
          const head = preview.slice(0, 96);
          if (DEBUG) {
            console.groupCollapsed('[audio_response]');
            console.log('frames:', frames.length, 'times[0..3]:', times.slice(0,4), 'head:', head);
            console.groupEnd();
          }
          queueAudio(b64, frames, times, `head=${head}â€¦`);
          break;
        }

        case 'response_done':
          flushTokenBuffer();
          logLine($('#evtLog'), `[${now()}] response_done timings=${JSON.stringify(msg.timings || {})}`);
          break;

        case 'response_ended':
          flushTokenBuffer();
          logLine($('#evtLog'), `[${now()}] response_ended`);
          break;

        case 'text_query':
          logLine($('#evtLog'), `[${now()}] echo text_query "${(msg.text||'').slice(0,200)}"`);
          break;

        case 'pong':
          logLine($('#evtLog'), `[${now()}] pong`);
          break;

        case 'error':
          logLine($('#evtLog'), `[${now()}] ERROR ${msg.message || 'unknown'}`);
          break;

        default:
          logLine($('#evtLog'), `[${now()}] ${t || 'unknown'} ${JSON.stringify(msg)}`);
      }
    };
  };

  $('#disconnectBtn').onclick = (e) => { e.preventDefault(); if (ws) { ws.close(); ws = null; } };
  $('#btnPing').onclick = (e) => { e.preventDefault(); if (ws && ws.readyState === 1) ws.send(JSON.stringify({type:'ping'})); };
  $('#btnToggleMute').onclick = (e) => {
    e.preventDefault();
    if (!ws || ws.readyState !== 1) return;
    const nextMuted = !audioMuted;
    audioEl.muted = nextMuted;
    setAudioBadge(nextMuted);
    ws.send(JSON.stringify({ type: nextMuted ? 'mute_audio' : 'unmute_audio' }));
  };
  $('#btnStopAudio').onclick = (e) => {
    e.preventDefault();
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ type: 'stop_audio' }));
    clearAudioQueue();
  };

  $('#sendBtn').onclick = sendText;
  $('#chatInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendText(); }});
  function sendText(){
    if (!ws || ws.readyState !== 1) return;
    const text = $('#chatInput').value.trim();
    if (!text) return;
    const muted = $('#muteOnSend').checked;
    ws.send(JSON.stringify({
      type: 'text_query',
      text,
      local_time: new Date().toLocaleString(),
      muteAudio: muted
    }));
    $('#chatInput').value = '';
  }

  // ---------- Push-to-Talk ----------
  let mediaStream = null, recorder = null, chunks = [];
  let recMime = 'audio/webm';

  function pickRecorderMime() {
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4;codecs=mp4a.40.2',
      'audio/mp4',
      'audio/ogg;codecs=opus',
      'audio/ogg'
    ];
    for (const m of candidates) {
      if (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) {
        return m;
      }
    }
    return 'audio/webm';
  }

  async function ensureMic() {
    try { return await navigator.mediaDevices.getUserMedia({ audio: true }); }
    catch { return null; }
  }

  function updateMicPermBadge() {
    const btn = $('#micPermBtn');
    if (navigator.permissions && navigator.permissions.query) {
      navigator.permissions.query({ name: 'microphone' }).then(st => {
        const denied = st.state === 'denied';
        btn.classList.toggle('hidden', !denied);
        $('#micStatus').textContent = `mic: ${st.state}`;
      }).catch(() => {});
    }
  }

  async function startPTT() {
    if (!ws || ws.readyState !== 1) return;
    $('#pttButton').classList.add('ring-4','ring-emerald-300');
    $('#micStatus').textContent = 'recordingâ€¦';
    try {
      mediaStream = await ensureMic();
      if (!mediaStream) {
        $('#micStatus').textContent = 'mic blocked/denied';
        $('#micPermBtn').classList.remove('hidden');
        $('#pttButton').classList.remove('ring-4','ring-emerald-300');
        return;
      }
      recMime = pickRecorderMime();
      recorder = new MediaRecorder(mediaStream, { mimeType: recMime, audioBitsPerSecond: 64000 });
      chunks = [];
      recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) chunks.push(ev.data); };
      recorder.start();
    } catch (e) {
      $('#micStatus').textContent = `! mic error: ${e}`;
      $('#micPermBtn').classList.remove('hidden');
      $('#pttButton').classList.remove('ring-4','ring-emerald-300');
    }
  }

  async function stopPTT(send=true) {
    $('#pttButton').classList.remove('ring-4','ring-emerald-300');
    try {
      if (!recorder) { $('#micStatus').textContent = 'mic: idle'; return; }
      await new Promise(res => { recorder.onstop = res; recorder.stop(); });
      const blob = new Blob(chunks, { type: recMime });
      if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
      recorder = null; mediaStream = null;
      const dataUrl = await blobToBase64(blob);
      const b64 = (dataUrl.split(',')[1] || '');
      if (send && ws && ws.readyState === 1) {
        ws.send(JSON.stringify({
          type: 'audio_query',
          audio: dataUrl,
          format: (recMime.includes('mp4') ? 'm4a' : recMime.includes('ogg') ? 'ogg' : 'webm'),
          muteAudio: $('#muteOnSend').checked
        }));
        logLine($('#evtLog'), `[${now()}] sent audio_query size=${b64.length} fmt=${recMime}`);
        $('#micStatus').textContent = `sent (${(blob.size/1024).toFixed(1)} KB)`;
      } else {
        $('#micStatus').textContent = 'not connected';
      }
    } catch (e3) {
      $('#micStatus').textContent = `! send error: ${e3}`;
    } finally {
      chunks = [];
      setTimeout(()=>$('#micStatus').textContent='mic: idle', 800);
    }
  }

  const ptt = $('#pttButton');
  ptt.addEventListener('mousedown', (e)=>{ e.preventDefault(); startPTT(); });
  ptt.addEventListener('touchstart', (e)=>{ e.preventDefault(); startPTT(); }, {passive:false});
  const finish = (e)=>{ e.preventDefault(); stopPTT(true); };
  ptt.addEventListener('mouseup', finish);
  ptt.addEventListener('mouseleave', (e)=>{ if (recorder) stopPTT(true); });
  ptt.addEventListener('touchend', finish, {passive:false});
  ptt.addEventListener('touchcancel', (e)=>{ e.preventDefault(); stopPTT(false); }, {passive:false});

  $('#micPermBtn').onclick = async (e) => {
    e.preventDefault();
    $('#micStatus').textContent = 'requesting micâ€¦';
    const stream = await ensureMic();
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      $('#micPermBtn').classList.add('hidden');
      $('#micStatus').textContent = 'mic: granted';
    } else {
      $('#micStatus').textContent = 'mic: denied';
    }
  };

  // panel copy/clear
  $('#textCopy').onclick = ()=>copyText($('#textTokens'));
  $('#textClear').onclick = ()=>clearEl($('#textTokens'));
  $('#slidesCopy').onclick = ()=>copyText($('#slidesLog'));
  $('#slidesClear').onclick = ()=>clearEl($('#slidesLog'));
  $('#audioCopy').onclick = ()=>copyText($('#audioLog'));
  $('#audioClear').onclick = ()=>{ clearEl($('#audioLog')); clearAudioQueue(); };
  $('#evtCopy').onclick = ()=>copyText($('#evtLog'));
  $('#evtClear').onclick = ()=>clearEl($('#evtLog'));

  // boot
  initThree();
  updateMicPermBadge();
  </script>

</body>
</html>
